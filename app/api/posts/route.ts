import { NextResponse } from 'next/server';


const posts = [
  {
    id: 'a1b2c3d4-e5f6-7890-1234-567890abcdef',
    title: 'HTML Tables: Structuring Data on the Web',
    category: 'html',
    slug: 'html-tables-structuring-data-on-the-web',
    img: '/images/articles/html1.jpg',
    description: 'HTML tables are fundamental for presenting tabular data in a structured and organized manner on web pages. They are designed to display information in rows and columns, making complex datasets easily digestible for users. To create a basic table, you start with the `<table>` tag, which acts as the container for all table content. Inside the `<table>` tag, you define table rows using the `<tr>` (table row) tag. Each `<tr>` can then contain either table data cells (`<td>`) or table header cells (`<th>`). The `<td>` tag is used for standard data, while `<th>` is specifically for column or row headers, which are typically bolded and centered by default, providing clear labels for your data. Beyond the basic structure, HTML offers attributes to enhance table appearance, though modern web development increasingly relies on CSS for styling. Historically, attributes like `border`, `cellpadding`, and `cellspacing` were common for controlling borders, internal cell spacing, and spacing between cells, respectively. While these attributes still function, using CSS properties like `border`, `padding`, and `margin` offers more control and flexibility for a consistent design across your website. Tables are ideal for a showing data like schedules, pricing, or comparisons. However, for layout purposes, modern web design prefers CSS over using tables for better accessibility and responsiveness. Proper semantic use of tables improves not only the user experience but also SEO, as search engines can better understand and index your structured data.',
    type: 'article'
  },
  {
    id: 'f7e8d9c0-b1a2-3456-7890-abcdef123456',
    title: 'HTML Forms: Collecting User Input',
    category: 'html',
    slug: 'html-forms-collecting-user-input',
    img: '/images/articles/html2.jpg',
    description: 'HTML forms are indispensable for interactive websites, serving as the primary mechanism to collect data from users. Whether it\'s a search bar, a login page, a contact form, or an online survey, forms enable communication between the user and the web server. The foundation of any form is the `<form>` tag, which encloses all input elements. Key attributes of the `<form>` tag include `action`, specifying the URL where the form data will be sent upon submission, and `method`, which defines the HTTP method (commonly `GET` or `POST`) used for sending the data. `GET` appends form data to the URL, making it visible, and is suitable for non-sensitive data like search queries. `POST` sends data in the HTTP request body, making it more secure for sensitive information like passwords or credit card details. Inside the form, you\'ll find various input types, each tailored for different data. The `<input>` tag is versatile, with its `type` attribute determining its behavior: `text` for single-line text input, `password` for hidden text, `email` for email addresses, `number` for numeric input, `checkbox` for multiple selections, `radio` for single selections from a group, `submit` for a submission button, and `file` for uploading files, among others. Other crucial form elements include `<textarea>` for multi-line text input, `<select>` for dropdown lists with `<option>` tags defining the choices, and `<button>` for customizable clickable buttons. Each input element should ideally have a `name` attribute, as this name-value pair is what gets sent to the server. For improved accessibility and user experience, `<label>` tags should be associated with input fields using the `for` attribute (matching the input\'s `id`). This allows users to click the label to focus on the input, and screen readers can announce the purpose of the input. Client-side validation using HTML5 attributes like `required`, `minlength`, `maxlength`, `pattern`, and `type="email"` can provide immediate feedback to users and reduce invalid submissions, improving the overall user journey.',
    type: 'article'
  },
  {
    id: '1a2b3c4d-5e6f-7890-abcd-ef1234567890',
    title: 'HTML Semantics: Building Meaningful Web Pages',
    category: 'html',
    slug: 'html-semantics-building-meaningful-web-pages',
    img: '/images/articles/html1.jpg',
    description: 'Semantic HTML is about using HTML elements for their intended purpose, conveying meaning to both browsers and developers, beyond just how the content looks. Instead of using generic `<div>` elements for everything, semantic tags like `<header>`, `<nav>`, `<main>`, `<article>`, `<section>`, `<aside>`, and `<footer>` describe the type of content they contain. This approach makes your web pages more readable, maintainable, and significantly improves accessibility and SEO. For instance, `<h1>` to `<h6>` tags should be used for headings, not just for making text bold or larger; they establish a document outline that screen readers and search engines rely on. Similarly, `<p>` is for paragraphs of text, `<ul>` and `<ol>` for unordered and ordered lists, and `<a>` for hyperlinks. Using `<header>` clearly indicates the introductory content of a section or page, often containing a logo, site title, and navigation. `<nav>` explicitly defines navigation links. The `<main>` element should encapsulate the dominant content of the `<body>`, unique to that document. `<article>` is ideal for independent, self-contained content, such as a blog post or news story, while `<section>` groups related content within an article or other document structure. `<aside>` is for content indirectly related to the main content, like sidebars or pull quotes. Finally, `<footer>` typically contains copyright information, contact details, and related links. The benefits of semantic HTML are manifold. For accessibility, screen readers can interpret the structure and hierarchy of your page, allowing users with visual impairments to navigate content more efficiently. For SEO, search engines can better understand the content and context of your web page, potentially leading to improved rankings. For developers, semantic markup leads to cleaner, more understandable code, making it easier to collaborate and maintain projects. Embracing semantic HTML is a cornerstone of modern, responsible web development, ensuring your content is structured, accessible, and optimized for a wider audience.',
    type: 'article'
  },
  {
    id: '6g7h8i9j-0k1l-2345-6789-0abcdef12345',
    title: 'HTML Multimedia: Embedding Audio and Video',
    category: 'html',
    slug: 'html-multimedia-embedding-audio-and-video',
    img: '/images/articles/html2.jpg',
    description: 'Embedding multimedia, specifically audio and video, has become a core feature of modern web design, allowing for richer, more engaging user experiences. HTML5 introduced dedicated tags, `<audio>` and `<video>`, which provide native support for playing media directly in the browser, eliminating the need for third-party plugins like Flash. The `<video>` tag is used to embed video content. Its essential attribute is `src`, which points to the video file\'s URL. Other important attributes include `controls`, which adds default browser controls like play/pause, volume, and fullscreen; `autoplay`, which attempts to play the video as soon as the page loads (though often blocked by browsers for user experience reasons unless muted); `loop`, for continuous playback; `muted`, to start the video without sound; `poster`, to display an image before the video loads or plays; `width` and `height` to set the dimensions of the video player. It\'s good practice to include multiple `<source>` tags within both `<audio>` and `<video>` elements, each with a different format (e.g., MP4, WebM, Ogg for video; MP3, WAV, Ogg for audio) and a `type` attribute. This allows the browser to choose the first format it supports, ensuring broader compatibility across different browsers and devices. The `<audio>` tag functions similarly to `<video>`, but for audio files. It also supports `src`, `controls`, `autoplay`, and `loop` attributes. For both tags, you can include fallback content between the opening and closing tags. This content will be displayed if the user\'s browser does not support the `<audio>` or `<video>` elements or the specified media formats. This is a good practice for accessibility. Additionally, for video content, consider adding `<track>` tags with `kind="captions"` or `kind="subtitles"` to provide closed captions or subtitles, making your content accessible to a wider audience, including those with hearing impairments or who prefer to watch with text. Optimizing media files for the web is crucial; large files can significantly slow down page load times. Always compress your media and consider using responsive CSS to ensure videos and audio players scale correctly on different screen sizes, providing a seamless experience for all users.',
    type: 'article'
  },
  {
    id: '2k3l4m5n-6o7p-8901-2345-67890abcdef1',
    title: 'HTML Accessibility: Making Your Content Inclusive',
    category: 'html',
    slug: 'html-accessibility-making-your-content-inclusive',
    img: '/images/articles/html2.jpg',
    description: 'Web accessibility (often abbreviated as A11y) is the practice of designing and developing websites so that people with disabilities can perceive, understand, navigate, and interact with them. It\'s not just about compliance; it\'s about creating an inclusive web for everyone. HTML plays a critical role in establishing the foundational accessibility of a web page. A key aspect is the proper use of semantic HTML, as discussed previously. Screen readers and other assistive technologies rely heavily on the semantic structure of your HTML to convey meaning to users. For example, using `<h1>` for main headings and `<h2>` for subheadings creates a logical document outline that screen reader users can navigate quickly. Another vital accessibility feature is the `alt` attribute for `<img>` tags. This attribute provides a text alternative for images, which is read aloud by screen readers or displayed if the image fails to load. A descriptive `alt` text is crucial for conveying the image\'s content and purpose to users who cannot see it. For interactive elements, ensure they are keyboard accessible. Users who cannot use a mouse rely on keyboard navigation (Tab key, Enter key, Spacebar). HTML elements like `<button>`, `<a>`, and form inputs are keyboard accessible by default. If you create custom interactive components, use the `tabindex` attribute to manage their focus order and JavaScript to handle keyboard events. Labels for form controls are also fundamental. Associating a `<label>` with its `<input>` using the `for` and `id` attributes ensures that when a label is clicked, the corresponding input is focused, and screen readers can announce the label for the input. This is far superior to simply placing text next to an input. WAI-ARIA (Web Accessibility Initiative - Accessible Rich Internet Applications) attributes can be used to add semantic meaning to dynamic content, custom widgets, and JavaScript-driven elements that HTML alone cannot fully express. For instance, `aria-label`, `aria-describedby`, and `aria-hidden` provide additional context or control for assistive technologies. Lastly, ensure sufficient color contrast between text and background for users with low vision or color blindness. While this is primarily a CSS concern, the initial HTML structure sets the stage for a well-designed, accessible experience. Prioritizing accessibility from the start of your HTML development makes your website usable and welcoming for the broadest possible audience.',
    type: 'article'
  },
  {
    id: '3m4n5o6p-7q8r-9012-3456-7890abcdef12',
    title: 'CSS Selectors: Targeting Elements with Precision',
    category: 'css',
    slug: 'css-selectors-targeting-elements-with-precision',
    img: '/images/articles/css1.jpg',
    description: 'CSS selectors are the backbone of styling web pages, providing the means to target specific HTML elements and apply styles to them. Without effective selectors, your CSS rules would be aimless. Understanding the various types of selectors is crucial for writing efficient and maintainable stylesheets. The simplest selectors are **element selectors**, which target all instances of a specific HTML element, like `p { color: blue; }` to make all paragraphs blue. **Class selectors** are identified by a dot (`.`) followed by the class name (e.g., `.my-class { font-size: 16px; }`). These are highly versatile as multiple elements can share the same class, allowing you to apply a consistent style to a group of elements regardless of their tag name. **ID selectors** are prefixed with a hash (`#`) followed by the ID name (e.g., `#my-id { background-color: yellow; }`). IDs must be unique within a single HTML document, making ID selectors ideal for styling a very specific, solitary element. However, using IDs excessively in CSS can lead to specificity issues and make your styles harder to override. **Universal selectors** (`*`) target every element on the page, often used for global resets like `* { margin: 0; padding: 0; }`. **Attribute selectors** target elements based on their attributes and their values, such as `[type="text"] { border: 1px solid gray; }` to style all text input fields. **Descendant selectors** (` ` space) select an element that is a descendant of another, like `div p { margin-bottom: 10px; }` to target paragraphs only inside divs. **Child selectors** (`>`) are more specific, targeting direct children only, for example, `ul > li { list-style: none; }`. **Adjacent sibling selectors** (`+`) select an element directly following another sibling, while **general sibling selectors** (`~`) select all siblings that follow. **Pseudo-classes** target elements based on their state (e.g., `:hover`, `:active`, `:focus`) or position (`:first-child`, `:nth-child`). **Pseudo-elements** style specific parts of an element, like `::before` and `::after` for adding generated content, or `::first-line` for styling the first line of text. Combining these selectors allows for highly precise targeting, enabling you to create complex and dynamic visual designs with minimal effort. Mastering CSS selectors is a cornerstone of becoming proficient in web styling and ensures your designs are applied exactly where you intend them to be.',
    type: 'article'
  },
  {
    id: '4r5s6t7u-8v9w-0123-4567-890abcdef123',
    title: 'CSS Box Model: Understanding Layout and Spacing',
    category: 'css',
    slug: 'css-box-model-understanding-layout-and-spacing',
    img: '/images/articles/css2.jpg',
    description: 'The CSS Box Model is a fundamental concept that dictates how elements are rendered on a web page, understanding their dimensions, spacing, and borders. Every HTML element is essentially a rectangular box, and this model describes the components that make up that box: **content**, **padding**, **border**, and **margin**. The **content area** is where the actual content of the element (text, images, video) resides. Its dimensions are determined by the `width` and `height` CSS properties. This is the innermost layer of the box. Surrounding the content area is the **padding**. Padding creates space between the content and the element\'s border. It can be controlled using `padding-top`, `padding-right`, `padding-bottom`, `padding-left`, or the shorthand `padding` property. Padding adds to the overall size of the element, meaning if you have a content width of 100px and 10px of padding on each side, the content-plus-padding width becomes 120px. The **border** sits outside the padding and frames the element. You can define its `width`, `style` (e.g., `solid`, `dashed`), and `color` using properties like `border-width`, `border-style`, `border-color`, or the shorthand `border`. The border also adds to the element\'s total dimensions. For example, if your element has a 120px content-plus-padding width and a 2px border on each side, its total width becomes 124px. Finally, the **margin** is the outermost layer, creating space *outside* the border, separating the element from other elements on the page. Margins are transparent and do not affect the element\'s background color. Similar to padding, you can control margins using `margin-top`, `margin-right`, `margin-bottom`, `margin-left`, or the `margin` shorthand. Margins are crucial for controlling the spacing between elements and can also collapse vertically, where the larger of two adjacent vertical margins will be used, rather than summing them. By default, browsers use the `content-box` model, where the `width` and `height` properties refer only to the content area. However, the `border-box` model, set with `box-sizing: border-box;`, includes padding and border within the specified `width` and `height`, simplifying layout calculations. This `border-box` model is widely preferred in modern CSS for its more intuitive and predictable sizing behavior, making it easier to manage element dimensions in complex layouts.',
    type: 'article'
  },
  {
    id: '5x6y7z8a-9b0c-1234-5678-90abcdef1234',
    title: 'CSS Flexbox: Building Flexible Layouts',
    category: 'css',
    slug: 'css-flexbox-building-flexible-layouts',
    img: '/images/articles/css2.jpg',
    description: 'CSS Flexbox, formally known as the Flexible Box Layout module, is a one-dimensional layout method designed for distributing space among items in a container and aligning them. It\'s particularly effective for small-scale layouts, such as navigation bars, form elements, or distributing items within a section. Flexbox works on the concept of a **flex container** and **flex items**. To enable Flexbox, you set `display: flex;` or `display: inline-flex;` on a parent element, turning it into a flex container. Its direct children then become flex items. Once a container is flex, you can control the layout of its items along two axes: the **main axis** and the **cross axis**. The `flex-direction` property determines the direction of the main axis, which can be `row` (default, left-to-right), `row-reverse`, `column` (top-to-bottom), or `column-reverse`. The cross axis is perpendicular to the main axis. Properties applied to the flex container control the overall alignment and distribution of flex items. `justify-content` controls alignment along the main axis (e.g., `flex-start`, `flex-end`, `center`, `space-between`, `space-around`, `space-evenly`), distributing extra space when items aren\'t large enough to fill the container. `align-items` handles alignment along the cross axis (e.g., `flex-start`, `flex-end`, `center`, `stretch`, `baseline`), useful for vertically centering items or aligning them to the top or bottom of the container. `flex-wrap` dictates whether flex items should wrap to the next line if they exceed the container\'s width (`nowrap` is default, `wrap`, `wrap-reverse`). Properties applied to individual flex items control their sizing and alignment within the container. `flex-grow` defines how much a flex item will grow relative to the rest of the flex items if there\'s available space. `flex-shrink` defines how much a flex item will shrink relative to the rest if there\'s not enough space. `flex-basis` sets the initial size of a flex item before any growing or shrinking. The `flex` shorthand property combines `flex-grow`, `flex-shrink`, and `flex-basis`. `align-self` allows you to override the `align-items` value for a specific flex item. Flexbox has revolutionized responsive design, making it straightforward to create dynamic layouts that adapt to different screen sizes and orientations. It provides a powerful and intuitive way to manage spacing and alignment for a wide range of UI components, significantly simplifying many common layout challenges that were previously much more cumbersome to achieve with traditional CSS methods.',
    type: 'article'
  },
  {
    id: '6c7d8e9f-0a1b-2345-6789-0abcdef12345',
    title: 'CSS Grid: Creating Two-Dimensional Layouts',
    category: 'css',
    slug: 'css-grid-creating-two-dimensional-layouts',
    img: '/images/articles/css1.jpg',
    description: 'CSS Grid Layout is a powerful two-dimensional layout system that allows you to design complex, responsive web page layouts with rows and columns. Unlike Flexbox, which is one-dimensional (either rows or columns), Grid excels at arranging content both horizontally and vertically, making it ideal for entire page layouts, dashboards, or any design that requires a precise grid structure. To implement CSS Grid, you declare `display: grid;` or `display: inline-grid;` on a parent element, which becomes the **grid container**. Its direct children automatically become **grid items**. Once enabled, you define the grid\'s structure using properties on the container. `grid-template-columns` and `grid-template-rows` specify the number and size of your columns and rows, respectively. You can use fixed units (e.g., `px`, `em`, `rem`), percentages (`%`), or the flexible `fr` unit, which distributes available space proportionally. For example, `grid-template-columns: 1fr 2fr 1fr;` creates three columns where the middle column is twice as wide as the outer ones. `grid-gap` (or `gap` in modern CSS) is a shorthand for `row-gap` and `column-gap`, creating space between grid cells. You can also name grid lines or grid areas using `grid-template-areas` to simplify the placement of items and improve readability. For example, defining areas like `header`, `sidebar`, `main`, and `footer` in `grid-template-areas` allows you to place items by name. Properties applied to individual grid items control their placement within the grid. `grid-column-start`, `grid-column-end`, `grid-row-start`, and `grid-row-end` determine which grid lines an item spans. Shorthands like `grid-column` and `grid-row` simplify this. You can also use `grid-area` to place an item directly into a named grid area. `justify-items` and `align-items` control the alignment of content within individual grid cells along the column and row axes respectively, while `justify-content` and `align-content` distribute grid tracks within the container if there\'s extra space. CSS Grid offers unparalleled control over page structure, making it much easier to build robust and adaptive designs. It\'s a game-changer for responsive web development, allowing developers to create layouts that fluidly adapt to different screen sizes with significantly less code and complexity compared to older layout methods.',
    type: 'article'
  },
  {
    id: '7h8i9j0k-1l2m-3456-7890-abcdef123456',
    title: 'CSS Transitions and Animations: Adding Dynamic Effects',
    category: 'css',
    slug: 'css-transitions-and-animations-adding-dynamic-effects',
    img: '/images/articles/css1.jpg',
    description: 'CSS transitions and animations bring life to static web pages, allowing you to create smooth, engaging visual effects that enhance user experience. These features enable property changes to occur gradually over a specified duration, rather than instantly, making interactions more intuitive and visually appealing. **CSS Transitions** are used for simple, single-state changes. When a CSS property changes its value (e.g., on a `:hover` state, or when a class is added/removed with JavaScript), a transition allows you to define how that change should occur. The key properties for transitions are: `transition-property` (which CSS properties to animate, e.g., `all`, `color`, `transform`), `transition-duration` (how long the transition takes, e.g., `0.5s`), `transition-timing-function` (the speed curve of the transition, e.g., `ease`, `linear`, `ease-in-out`), and `transition-delay` (how long to wait before starting). You can use the `transition` shorthand property to combine these. For example, `transition: all 0.3s ease-in-out;` will smoothly animate all changes over 0.3 seconds with an ease-in-out timing. **CSS Animations**, on the other hand, provide more complex, multi-state effects. They allow you to define a sequence of keyframes, which are specific points in time where you want a set of CSS properties to have certain values. Animations are defined using the `@keyframes` rule, where you specify stages like `0%` (or `from`) and `100%` (or `to`), and intermediate percentages. Once keyframes are defined, you apply the animation to an element using properties like `animation-name` (the name of your `@keyframes` rule), `animation-duration`, `animation-timing-function`, `animation-delay`, `animation-iteration-count` (how many times the animation should run, e.g., `infinite`), `animation-direction` (e.g., `alternate`), and `animation-fill-mode` (what styles are applied before/after the animation). The `animation` shorthand combines these. For instance, `animation: bounce 2s infinite alternate;` would run an animation named "bounce" for 2 seconds, indefinitely, and alternate its direction each time. Both transitions and animations can be hardware-accelerated by the browser if properties like `transform` and `opacity` are used, leading to smoother performance. They significantly contribute to a polished and professional web presence, providing engaging feedback to user actions and adding a layer of dynamism that keeps visitors captivated.',
    type: 'article'
  },
  {
    id: 'proj-a1b2c3d4-e5f6-7890-1234-567890abcdef',
    title: 'Project: Build a Responsive HTML Table Dashboard',
    category: 'html',
    slug: 'build-responsive-html-table-dashboard',
    img: '/images/projects/Project1.jpg',
    description: 'This project challenges you to build a **responsive dashboard** using only HTML tables for data display, and minimal CSS for basic styling to ensure responsiveness. The goal is to create a dashboard that showcases various types of data in tabular format, such as sales figures, user statistics, or product inventories. Your dashboard should feature at least three distinct tables, each demonstrating different aspects of HTML table capabilities. For instance, one table could use `<thead>`, `<tbody>`, and `<tfoot>` for semantic structure, another might include `colspan` and `rowspan` to merge cells for complex layouts, and a third could showcase a simple, clean data presentation. Focus on using `<th>` tags effectively for clear headings and `<td>` for data cells. While the primary focus is HTML structure, you\'ll need to apply some basic CSS to make the tables **responsive**. This might involve using `display: block` on table elements at smaller screen sizes, or leveraging CSS properties like `overflow-x: auto` to allow horizontal scrolling on narrow viewports, preventing data from being cut off. You should also consider how to make the table headers "sticky" or visible even when scrolling horizontally. The project aims to solidify your understanding of how HTML tables are correctly structured for presenting tabular data, and how to make them adapt gracefully to different screen sizes without breaking the layout. This exercise will highlight the importance of semantic HTML for data organization and introduce you to initial responsive design considerations for tables. Think about how a user on a mobile device would interact with your dashboard and ensure the data remains readable and navigable. This project will serve as a strong foundation for understanding complex data presentation on the web.',
    type: 'project'
  },
  {
    id: 'proj-f7e8d9c0-b1a2-3456-7890-abcdef123456',
    title: 'Project: Develop a Multi-Step Contact Form',
    category: 'html',
    slug: 'develop-multi-step-contact-form',
    img: '/images/projects/Project2.jpg',
    description: 'For this project, you\'ll develop a **multi-step contact form** using HTML, focusing on accessible and semantically correct form elements. The form should be broken down into at least three distinct steps or sections, each collecting a specific set of user information. For example, the first step could gather basic contact details (name, email), the second could focus on the message subject and content, and the third might include optional preferences or file uploads. You\'ll need to utilize various HTML `<input>` types such as `text`, `email`, `tel`, `textarea` for multi-line messages, `checkbox` for opt-in options, and `radio` buttons for single-choice selections. Implement the `<select>` element with `<option>` tags for dropdown menus. A crucial part of this project is to ensure the form is highly **accessible**. This means properly associating `<label>` tags with their respective input fields using the `for` and `id` attributes. Implement HTML5 validation attributes like `required`, `pattern` (for specific formats like phone numbers), `minlength`, and `maxlength` to provide client-side validation, giving immediate feedback to users. You should also consider adding `placeholder` text for guidance. While the primary focus is HTML, you can use minimal CSS to visually separate the steps (e.g., using `display: none` on inactive steps and `display: block` on the current step, toggled by JavaScript later if you choose to extend this project beyond pure HTML). The project aims to deepen your understanding of HTML form structure, user input types, and the critical importance of accessibility in form design, laying the groundwork for interactive web applications. Think about the user journey and how to make filling out the form as smooth and error-free as possible.',
    type: 'project'
  },
  {
    id: 'proj-1a2b3c4d-5e6f-7890-abcd-ef1234567890',
    title: 'Project: Create a Blog Post Structure with Semantic HTML',
    category: 'html',
    slug: 'create-blog-post-structure-semantic-html',
    img: '/images/projects/Project3.jpg',
    description: 'This project involves creating the **semantic HTML structure for a single blog post page**. Your goal is to use HTML5 semantic elements to clearly define the different sections of a typical blog article, making it highly readable and understandable for both humans and machines (search engines, screen readers). Start by structuring the entire page with a `<header>` for the site-wide banner (e.g., logo, site title, main navigation), a `<main>` element to contain the primary content of the page, and a `<footer>` for copyright and contact information. Within the `<main>` element, focus on the blog post itself. This should primarily be enclosed in an `<article>` tag, signifying independent, self-contained content. Inside the `<article>`, use appropriate heading tags (`<h1>` for the post title, `<h2>` for major sections, `<h3>` for sub-sections) to create a clear content hierarchy. Utilize `<section>` tags to group related content within the article. For example, you might have `<section>`s for the introduction, main body paragraphs, and conclusion. Include a `<figure>` and `<figcaption>` for images within the article, providing semantic context for your visuals. Use `<ul>` and `<ol>` for lists, and `<blockquote>` for quoted content. An `<aside>` element can be used for related information like author bio, tags, or "read next" suggestions that are indirectly related to the main article content. This project emphasizes the importance of **semantic HTML** for improved accessibility, SEO, and maintainability. By properly structuring your content with meaningful tags, you\'ll create a robust foundation that assistive technologies can interpret effectively, and search engines can better index, leading to a more accessible and discoverable web presence. Focus on the logical flow of content and how each HTML tag contributes to conveying its meaning.',
    type: 'project'
  },
  {
    id: 'proj-6g7h8i9j-0k1l-2345-6789-0abcdef12345',
    title: 'Project: Embed Media Gallery with Fallbacks',
    category: 'html',
    slug: 'embed-media-gallery-with-fallbacks',
    img: '/images/projects/Project4.jpg',
    description: 'For this project, you\'ll build a simple **media gallery that embeds both audio and video content** using HTML5 `<audio>` and `<video>` tags. A key requirement is to implement **robust fallbacks** to ensure content is accessible across different browsers and devices, even if a preferred media format isn\'t supported. Create a page with at least two video elements and two audio elements. For each `<video>` element, include multiple `<source>` tags with different video formats (e.g., MP4, WebM, Ogg) and specify their `type` attributes. Do the same for each `<audio>` element, providing various audio formats (e.g., MP3, WAV, Ogg). Inside both the `<audio>` and `<video>` tags, provide **fallback content** (text or a link) that will be displayed if the browser does not support the element or any of the provided media formats. This ensures users on older browsers or those with specific configurations still get information about the media. Additionally, include the `controls` attribute for all media elements to provide standard playback controls (play/pause, volume, progress bar). For videos, consider adding a `poster` attribute to display a preview image before the video loads. To enhance accessibility, particularly for videos, include a `<track>` tag with `kind="captions"` for closed captions. This project will deepen your understanding of how to natively embed multimedia on the web, manage different media formats, and crucially, how to implement graceful degradation strategies through fallbacks. It will also touch upon the importance of providing accessible alternatives for media content.',
    type: 'project'
  },
  {
    id: 'proj-2k3l4m5n-6o7p-8901-2345-67890abcdef1',
    title: 'Project: Create an Accessible Navigation Menu',
    category: 'html',
    slug: 'create-accessible-navigation-menu',
    img: '/images/projects/Project5.jpg',
    description: 'This project focuses on building a highly **accessible navigation menu** using semantic HTML. Your goal is to create a navigation structure that is usable and understandable by everyone, including users relying on screen readers or keyboard navigation. The main navigation should be enclosed within a `<nav>` element, as this explicitly identifies it as a navigation block to assistive technologies. Inside the `<nav>`, use an unordered list (`<ul>`) with list items (`<li>`) to represent your main navigation links. Each link should be an `<a>` tag with a meaningful `href` attribute. For sub-menus (if applicable), nest another `<ul>` within the `<li>` of the parent item. Implement proper tab order and focus management primarily through HTML structure. Standard HTML elements like `<a>` are keyboard focusable by default. If you create custom interactive components, use the `tabindex` attribute to manage their focus order and JavaScript to handle keyboard events. Labels for form controls are also fundamental. Associating a `<label>` with its `<input>` using the `for` and `id` attributes ensures that when a label is clicked, the corresponding input is focused, and screen readers can announce the label for the input. This is far superior to simply placing text next to an input. WAI-ARIA (Web Accessibility Initiative - Accessible Rich Internet Applications) attributes can be used to add semantic meaning to dynamic content, custom widgets, and JavaScript-driven elements that HTML alone cannot fully express. For instance, `aria-label`, `aria-describedby`, and `aria-hidden` provide additional context or control for assistive technologies. Lastly, ensure sufficient color contrast between text and background for users with low vision or color blindness. While this is primarily a CSS concern, the initial HTML structure sets the stage for a well-designed, accessible experience. Prioritizing accessibility from the start of your HTML development makes your website usable and welcoming for the broadest possible audience.',
    type: 'project'
  },
  {
    id: 'proj-3m4n5o6p-7q8r-9012-3456-7890abcdef12',
    title: 'Project: Style a Portfolio Page with Advanced CSS Selectors',
    category: 'css',
    slug: 'style-portfolio-page-advanced-css-selectors',
    img: '/images/projects/Project6.jpg',
    description: 'This project challenges you to style a **portfolio page** specifically by leveraging a wide range of advanced CSS selectors. Instead of relying solely on classes and IDs, your goal is to demonstrate a deep understanding of how to target elements precisely using various selector types. Create an HTML structure for a portfolio page that includes sections for "About Me," "Projects," and "Contact." Within these sections, use a mix of HTML elements (e.g., `<div>`, `<span>`, `p`, `h2`, `ul`, `li`, `a`). Your CSS should then target these elements using: **descendant selectors** (e.g., `section p`), **child selectors** (e.g., `ul > li`), **adjacent sibling selectors** (e.g., `h2 + p`), and **general sibling selectors** (e.g., `h2 ~ p`). Experiment with **attribute selectors** to style elements based on their attributes (e.g., `a[target="_blank"] { color: blue; }`). Crucially, incorporate **pseudo-classes** like `:hover`, `:focus`, `:active` for interactive elements (buttons, links), and structural pseudo-classes such as `:first-child`, `:last-child`, `:nth-child(even)`, `:nth-of-type(3)` to style specific list items or paragraphs. Utilize **pseudo-elements** like `::before` and `::after` to add decorative content or custom list markers. The aim is to achieve a visually appealing and well-structured portfolio page purely through precise selector usage, demonstrating that you can style elements based on their relationships, states, and attributes without over-relying on utility classes. This project will solidify your command over CSS specificity and efficiency in targeting elements, which is fundamental for writing scalable and maintainable stylesheets.',
    type: 'project'
  },
  {
    id: 'proj-4r5s6t7u-8v9w-0123-4567-890abcdef123',
    title: 'Project: Recreate a Newspaper Layout with CSS Box Model',
    category: 'css',
    slug: 'recreate-newspaper-layout-css-box-model',
    img: '/images/projects/Project7.jpg',
    description: 'In this project, you will **recreate a simplified newspaper article layout** primarily by manipulating the CSS Box Model properties. The goal is to understand how `width`, `height`, `padding`, `border`, and `margin` interact to control the size and spacing of elements, mimicking a traditional newspaper column structure. Your HTML should contain a main article section with a title, a byline, and several paragraphs of text, potentially with an image. Apply CSS to create at least two or three columns for the main article text. This can be achieved by setting specific widths and then using `margin` and `padding` to control the spacing between columns and the inner spacing of each text block. Experiment with different `padding` values to create varying internal whitespace around your text and images. Apply `border` properties to simulate article separators, image frames, or section outlines. Pay close attention to how `margin-collapse` behaves when you set vertical margins between paragraphs or sections. Crucially, explicitly set `box-sizing: border-box;` on all elements using the universal selector (`*`). This will ensure that when you set `width` and `height`, `padding` and `border` are included within those dimensions, making layout calculations much more intuitive and predictable. This project will highlight the significance of the Box Model in controlling element dimensions and their relationships on the page. By carefully adjusting these properties, you\'ll gain a deep understanding of how space is consumed and distributed within the document flow, which is foundational for all CSS layouts.',
    type: 'project'
  },
  {
    id: 'proj-5x6y7z8a-9b0c-1234-5678-90abcdef1234',
    title: 'Project: Design a Responsive Navigation Bar with Flexbox',
    category: 'css',
    slug: 'design-responsive-navigation-bar-flexbox',
    img: '/images/projects/Project8.jpg',
    description: 'This project challenges you to design and implement a **fully responsive navigation bar** using CSS Flexbox. Your navigation bar should adapt seamlessly from a desktop view (horizontal links) to a mobile view (stacked links or a menu icon that toggles a vertical menu). Start with a semantic HTML `<nav>` element containing an unordered list (`<ul>`) of links. On larger screens, use `display: flex;` on the `<ul>` to arrange the `<li>` items horizontally. Experiment with `justify-content` (e.g., `space-around`, `space-between`) to distribute the links evenly, and `align-items` to vertically center them. When the screen size shrinks (you can use CSS Media Queries for this), the navigation should switch its layout. One common approach is to change `flex-direction` to `column` and potentially hide the links by default, showing them when a "hamburger" menu icon is clicked (though the click functionality would require JavaScript, the CSS for the stacked layout is pure Flexbox). Focus on how `flex-grow`, `flex-shrink`, and `flex-basis` can be used to control the sizing of individual navigation items. Ensure that padding and margins are used effectively within the Flexbox container and items to create appropriate spacing and visual balance. This project will solidify your understanding of Flexbox as a powerful one-dimensional layout tool, particularly for building highly adaptive components like navigation bars, which are crucial for responsive web design. You\'ll learn to think about how elements can be arranged and rearranged efficiently based on available screen space.',
    type: 'project'
  },
  {
    id: 'proj-6c7d8e9f-0a1b-2345-6789-0abcdef12345',
    title: 'Project: Build a Photo Gallery Grid Layout',
    category: 'css',
    slug: 'build-photo-gallery-grid-layout',
    img: '/images/projects/Project9.jpg',
    description: 'For this project, you will build a **responsive photo gallery** using CSS Grid Layout. The goal is to create a dynamic grid of images that adapts elegantly to different screen sizes, showcasing your mastery of two-dimensional layout. Your HTML should consist of a container `<div>` with several image items (each containing an `<img>` tag and perhaps a caption). On the grid container, apply `display: grid;`. Then, use `grid-template-columns` to define the number of columns. For responsiveness, consider using `repeat()` with `auto-fit` or `auto-fill` and `minmax()` (e.g., `grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));`). This will automatically adjust the number of columns based on the available space and the minimum width of your image items. Use `grid-gap` (or `gap`) to create consistent spacing between your images. Experiment with spanning items across multiple rows or columns using `grid-column` and `grid-row` properties for a more asymmetrical or visually interesting layout. For instance, make one or two images larger than the others, spanning 2x2 grid cells. You can also name specific grid areas and place images into those named areas using `grid-area`. Ensure that your images within the grid cells are well-behaved, possibly using `object-fit: cover;` to prevent distortion while filling the space. This project will provide hands-on experience with CSS Grid\'s powerful capabilities for creating complex, two-dimensional layouts, and will demonstrate how to build truly responsive image galleries that look great on any device.',
    type: 'project'
  },
  {
    id: 'proj-7h8i9j0k-1l2m-3456-7890-abcdef123456',
    title: 'Project: Animate an On-Scroll Reveal Effect',
    category: 'css',
    slug: 'animate-on-scroll-reveal-effect',
    img: '/images/projects/Project10.jpg',
    description: 'This project challenges you to implement an **"on-scroll reveal" animation effect** using CSS animations and transitions (though detecting scroll position often requires JavaScript, the animation itself is pure CSS). The idea is that as a user scrolls down the page, elements (like text blocks, images, or cards) smoothly slide or fade into view rather than appearing instantly. Create an HTML page with several distinct sections, each containing some content (e.g., a heading, a paragraph, an image). Initially, hide these sections or position them off-screen using CSS (e.g., `opacity: 0; transform: translateY(50px);`). Then, define a `@keyframes` animation (e.g., `fadeInUp`) that brings the elements into full view (e.g., `opacity: 1; transform: translateY(0);`). The core of this project lies in applying this animation **only when the element becomes visible in the viewport**. While the *trigger* for applying the animation class will likely involve JavaScript (checking `Intersection Observer` or `getBoundingClientRect()`), your focus in CSS is to define the elegant animation itself. Experiment with different `animation-timing-function` values (e.g., `ease-out`, `cubic-bezier`) to create various effects. You can also use `animation-delay` to stagger the appearance of multiple elements in a section. Additionally, if you choose a simpler approach without JavaScript, you could use CSS `transition` properties on elements that change `opacity` or `transform` when a class is added to them (perhaps by a parent `:hover` for a simpler effect, but for scroll reveal, JavaScript is typical). This project will deepen your understanding of CSS animations, keyframes, and the nuances of creating dynamic, visually engaging user experiences that respond to user interaction, specifically scrolling behavior. It bridges the gap between static styling and fluid, interactive web design.',
    type: 'project'
  },
];

export async function GET(request: Request) {
    const { searchParams } = new URL(request.url);
    const category = searchParams.get('category');

    let filteredProducts = posts;
    if (category) {
        filteredProducts = posts.filter(articl => articl.category === category);
    }

  
  return NextResponse.json(filteredProducts, { status: 200 });
}